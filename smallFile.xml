<?xml version="1.0" encoding="utf-8"?>
<posts>
  <row Id="891031" PostTypeId="1" AcceptedAnswerId="891059" CreationDate="2009-05-21T01:31:33.970" Score="25" ViewCount="58149" Body="&lt;p&gt;I didn't find it, yet. Did I miss something? &#xA;I know a factorial method is a common example programm for beginners. But wouldn't it be usefull to have a standard implementation for this one to reuse?&#xA;I could use such a method with standard types (int, long...) and with BigInteger / BigDecimal, too.&lt;/p&gt;&#xA;" OwnerDisplayName="c0d3x" LastActivityDate="2014-04-04T10:50:08.857" Title="Is there a method that calculates a factorial in Java?" Tags="&lt;java&gt;" AnswerCount="14" CommentCount="0" FavoriteCount="4" />
  <row Id="2486527" PostTypeId="1" AcceptedAnswerId="2486540" CreationDate="2010-03-21T09:28:15.743" Score="1" ViewCount="132" Body="&lt;pre&gt;&lt;code&gt;    public static int ABC(int x, int y)&#xA;{&#xA;    if(y==0)&#xA;        return(1);&#xA;    else&#xA;        return(x * ABC(x,y-1));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;what this function do please ? factorial ?&lt;/p&gt;&#xA;" OwnerUserId="298146" LastActivityDate="2010-03-21T09:31:27.873" Title="what this function do please ? (java)" Tags="&lt;java&gt;" AnswerCount="2" CommentCount="1" />
  <row Id="7459215" PostTypeId="1" AcceptedAnswerId="7459522" CreationDate="2011-09-18T02:58:15.103" Score="2" ViewCount="333" Body="&lt;p&gt;Suppose I have a method to calculate combinations of r items from n items:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    public static long combi(int n, int r) {&#xA;&#xA;        if ( r == n) return 1;&#xA;        long numr = 1;&#xA;        for(int i=n; i &amp;gt; (n-r); i--) {&#xA;            numr *=i;&#xA;&#xA;        }&#xA;        return numr/fact(r);&#xA;&#xA;    }&#xA;&#xA;&#xA;public static long fact(int n) {&#xA;&#xA;        long rs = 1;&#xA;        if(n &amp;lt;2) return 1;&#xA;        for (int i=2; i&amp;lt;=n; i++) {&#xA;            rs *=i;&#xA;        }&#xA;        return rs;&#xA;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;As you can see it involves factorial which can easily overflow the result. For example if I have fact(200) for the foctorial method I get zero. The question is why do I get zero?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Secondly how do I deal with overflow in above context? The method should return largest possible number to fit in long if the result is too big instead of returning wrong answer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One approach (but this could be wrong) is that if the result exceed some large number for example 1,400,000,000 then return remainder of result modulo &#xA;1,400,000,001. Can you explain what this means and how can I do that in Java?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that I do not guarantee that above methods are accurate for calculating factorial and combinations. Extra bonus if you can find errors and correct them.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that I can only use int or long and if it is unavoidable, can also use double. Other data types are not allowed.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am not sure who marked this question as homework. This is NOT homework. I wish it was homework and i was back to future, young student at university. But I am old with more than 10 years working as programmer. I just want to practice developing highly optimized solutions in Java. In our times at university, Internet did not even exist. Today's students are lucky that they can even post their homework on site like SO.&lt;/p&gt;&#xA;" OwnerUserId="574122" LastEditorUserId="574122" LastEditDate="2011-09-18T17:42:00.553" LastActivityDate="2011-09-19T02:44:27.127" Title="Dealing with overflow in Java without using BigInteger" Tags="&lt;java&gt;" AnswerCount="7" CommentCount="5" FavoriteCount="1" />
  <row Id="7459522" PostTypeId="2" ParentId="7459215" CreationDate="2011-09-18T04:43:15.500" Score="1" Body="&lt;p&gt;To answer your first question (why did you get zero), the values of fact() as computed by modular arithmetic were such that you hit a result with all 64 bits zero!  Change your fact code to this:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public static long fact(int n) {&#xA;    long rs = 1;&#xA;    if( n &amp;lt;2) return 1;&#xA;    for (int i=2; i&amp;lt;=n; i++) {&#xA;        rs *=i;&#xA;        System.out.println(rs);&#xA;    }&#xA;    return rs;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Take a look at the outputs!  They are very interesting.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now onto the second question....&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It looks like you want to give exact integer (er, &lt;code&gt;long&lt;/code&gt;) answers for values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt; that fit, and throw an exception if they do not.  This is a fair exercise.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To do this properly you should not use factorial at all.  The trick is to recognize that &lt;code&gt;C(n,r)&lt;/code&gt; can be computed incrementally by adding terms.  This can be done using recursion with memoization, or by the multiplicative formula mentioned by Stefan Kendall.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As you accumulate the results into a &lt;code&gt;long&lt;/code&gt; variable that you will use for your answer, check the value after each addition to see if it goes negative.  When it does, throw an exception.  If it stays positive, you can safely return your accumulated result as your answer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To see why this works consider Pascal's triangle&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1&#xA;1  1&#xA;1  2   1&#xA;1  3   3   1&#xA;1  4   6   4   1&#xA;1  5  10  10   5  1&#xA;1  6  15  20  15  6  1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;which is generated like so:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;C(0,0) = 1 (base case)&#xA;C(1,0) = 1 (base case)&#xA;C(1,1) = 1 (base case) &#xA;C(2,0) = 1 (base case) &#xA;C(2,1) = C(1,0) + C(1,1) = 2&#xA;C(2,2) = 1 (base case)&#xA;C(3,0) = 1 (base case)&#xA;C(3,1) = C(2,0) + C(2,1) = 3&#xA;C(3,2) = C(2,1) + C(2,2) = 3&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;When computing the value of &lt;code&gt;C(n,r)&lt;/code&gt; using memoization, store the results of recursive invocations as you encounter them in a suitable structure such as an array or hashmap. Each value is the sum of two &lt;em&gt;smaller&lt;/em&gt; numbers.  The numbers start small and are always positive.  Whenever you compute a new value (let's call it a subterm) you are adding smaller positive numbers.  Recall from your computer organization class that whenever you add two modular positive numbers, there is an overflow &lt;em&gt;if and only if&lt;/em&gt; the sum is negative.  It only takes one overflow in the whole process for you to know that the &lt;code&gt;C(n,r)&lt;/code&gt; you are looking for is too large.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This line of argument could be turned into a nice inductive proof, but that might be for another assignment, and perhaps another StackExchange site.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;ADDENDUM&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here is a complete application you can run.  (I haven't figured out how to get Java to run on codepad and ideone).&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/**&#xA; * A demo showing how to do combinations using recursion and memoization, while detecting&#xA; * results that cannot fit in 64 bits.&#xA; */&#xA;public class CombinationExample {&#xA;&#xA;    /**&#xA;     * Returns the number of combinatios of r things out of n total.&#xA;     */&#xA;    public static long combi(int n, int r) {&#xA;        long[][] cache = new long[n + 1][n + 1];&#xA;        if (n &amp;lt; 0 || r &amp;gt; n) {&#xA;            throw new IllegalArgumentException(&quot;Nonsense args&quot;);&#xA;        }&#xA;        return c(n, r, cache);&#xA;    }&#xA;&#xA;    /**&#xA;     * Recursive helper for combi.&#xA;     */&#xA;    private static long c(int n, int r, long[][] cache) {&#xA;        if (r == 0 || r == n) {&#xA;            return cache[n][r] = 1;&#xA;        } else if (cache[n][r] != 0) {&#xA;            return cache[n][r];&#xA;        } else {&#xA;            cache[n][r] = c(n-1, r-1, cache) + c(n-1, r, cache);&#xA;            if (cache[n][r] &amp;lt; 0) {&#xA;                throw new RuntimeException(&quot;Woops too big&quot;);&#xA;            }&#xA;            return cache[n][r];&#xA;        }&#xA;    }&#xA;&#xA;    /**&#xA;     * Prints out a few example invocations.&#xA;     */&#xA;    public static void main(String[] args) {&#xA;        String[] data = (&quot;0,0,3,1,4,4,5,2,10,0,10,10,10,4,9,7,70,8,295,100,&quot; +&#xA;                &quot;34,88,-2,7,9,-1,90,0,90,1,90,2,90,3,90,8,90,24&quot;).split(&quot;,&quot;);&#xA;        for (int i = 0; i &amp;lt; data.length; i += 2) {&#xA;            int n = Integer.valueOf(data[i]);&#xA;            int r = Integer.valueOf(data[i + 1]);&#xA;            System.out.printf(&quot;C(%d,%d) = &quot;, n, r);&#xA;            try {&#xA;                System.out.println(combi(n, r));&#xA;            } catch (Exception e) {&#xA;                System.out.println(e.getMessage());&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Hope it is useful.  It's just a quick hack so you might want to clean it up a little....  Also note that a good solution would use proper unit testing, although this code does give nice output.&lt;/p&gt;&#xA;" OwnerUserId="831878" LastEditorUserId="831878" LastEditDate="2011-09-19T02:44:27.127" LastActivityDate="2011-09-19T02:44:27.127" CommentCount="2" />
  <row Id="7486993" PostTypeId="1" AcceptedAnswerId="7487039" CreationDate="2011-09-20T14:36:55.300" Score="0" ViewCount="784" Body="&lt;p&gt;Trying to figure out the best place to put a try catch statement when a recursive call is placed. The factorial computation is done with long datatype. Expecting an exception to be thrown when the factorial becomes too huge to fit into a long variable.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However the code is showing factorial = 0 whenever it's too large. No exception is being thrown. So is there a problem with the try-catch placement or does putting over-large numbers throw no exception?&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Fact&#xA;{&#xA;    static long fact(long n)&#xA;    {&#xA;       if(n==1)&#xA;           return 1;&#xA;        return n*fact(n-1);&#xA;    }&#xA;&#xA;public static void main(String args[])&#xA;{&#xA;    try{&#xA;        long f = fact(555);&#xA;        System.out.println(&quot;Factorial = &quot;+f);&#xA;    }&#xA;    catch(Exception e){&#xA;            System.out.println(&quot;Exception = &quot;+e);&#xA;    }&#xA;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="297353" LastEditorUserId="297353" LastEditDate="2011-09-20T14:45:11.167" LastActivityDate="2011-09-20T15:41:04.587" Title="Try-catch placement in a recursive Java function call" Tags="&lt;java&gt;" AnswerCount="3" CommentCount="3" />
  <row Id="7937798" PostTypeId="1" AcceptedAnswerId="7937807" CreationDate="2011-10-29T08:32:58.210" Score="0" ViewCount="66" Body="&lt;p&gt;This is a factorial program in java, its not working please let me know the errors. Thanks!&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Fact {&#xA;   public static void main(String[] args) {&#xA;&#xA;      int i=5,num=1;&#xA;&#xA;      while(i&amp;gt;1) {&#xA;         num=num*i;&#xA;      }&#xA;      i--;&#xA;&#xA;      System.out.println(&quot;Value: &quot; + num);      &#xA;   }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="855360" LastEditorUserId="418556" LastEditDate="2011-10-29T11:18:53.313" LastActivityDate="2011-10-29T11:18:53.313" Title="Simple Java Error" Tags="&lt;java&gt;&lt;coding-style&gt;" AnswerCount="2" CommentCount="2" />
  <row Id="8183426" PostTypeId="1" AcceptedAnswerId="8183502" CreationDate="2011-11-18T13:48:53.170" Score="5" ViewCount="35163" Body="&lt;p&gt;I am learning Java using the book Java: The Complete Reference.&#xA;Currently I am working on the topic Recursion.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Please Note:&lt;/strong&gt; There are similar questions on stackoverflow. I searched them but I didn't find the solution to my question. I am confused with the logic in the following program.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If I run the below program, it produces the correct output, but I didn't understand the logic.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;I didn't understand the logic in the following line : &lt;strong&gt;result = fact(n-1) * n;&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;From my knowledge, If we pass the value of n=4 as shown in the below program, &lt;/li&gt;&#xA;&lt;li&gt;Then, 3 * 4 is stored in the result i.e., 12. &lt;/li&gt;&#xA;&lt;li&gt;Again, fact(n-1) is called. Then n becomes 3.&lt;/li&gt;&#xA;&lt;li&gt;Then the 2 * 3 is stored in the result replacing the previous 12.&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;I think you understood where I am stuck up/confused.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Thank you.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;pre&gt;&lt;code&gt;class Calculation&#xA;{&#xA;    int fact(int n)&#xA;    {&#xA;        int result;&#xA;&#xA;       if(n==1)&#xA;         return 1;&#xA;&#xA;       result = fact(n-1) * n;&#xA;       return result;&#xA;    }&#xA;}&#xA;&#xA;public class Factorial&#xA;{&#xA;     public static void main(String args[])&#xA;     {&#xA;       Calculation obj_one = new Calculation();&#xA;&#xA;       int a = obj_one.fact(4);&#xA;       System.out.println(&quot;The factorial of the number is : &quot; + a);&#xA;     }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="907629" LastEditorUserId="469220" LastEditDate="2011-11-18T13:52:29.123" LastActivityDate="2014-04-23T17:55:32.103" Title="Factorial using Recursion in Java" Tags="&lt;java&gt;&lt;recursion&gt;" AnswerCount="11" CommentCount="2" />
  <row Id="9712480" PostTypeId="1" CreationDate="2012-03-15T00:41:41.903" Score="0" ViewCount="1815" Body="&lt;p&gt;I've been using this factorial program for Java:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public static long factorial(int a) {&#xA;&#xA;    if(a&amp;lt;1)return 1;&#xA;    long result=1;&#xA;    long x=a;&#xA;    while(x&amp;gt;1)&#xA;    {&#xA;        result*=x; &#xA;&#xA;       x--;&#xA;    }&#xA;    return result;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;However, it seems to &quot;break&quot; and return a negative number after the factorial of 25. It returns a negative number for a while then just returns &quot;0.&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Am I doing anything wrong that is causing this?&lt;/p&gt;&#xA;" OwnerUserId="793602" LastEditorUserId="11343" LastEditDate="2012-05-04T22:41:19.320" LastActivityDate="2012-05-04T22:41:19.320" Title="Factorial in Java" Tags="&lt;java&gt;&lt;factorial&gt;" AnswerCount="6" CommentCount="4" FavoriteCount="1" />
  <row Id="10106500" PostTypeId="1" CreationDate="2012-04-11T13:07:02.807" Score="0" ViewCount="498" Body="&lt;p&gt;How i can create my own data type in java that could store a 16-byte integer value&lt;/p&gt;&#xA;&#xA;&lt;p&gt;the longest data-type in java by size is &quot;long&quot; which is 8-byte and it could store 19-digit integer value but, i want to find the factorial of 25 and the factorial of 25 is 26-digit(15511210043330985984000000). now the problem is i have no such a data-type in java that could store such huge value of 26-digits or more. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;if there is any &lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public long factorial(int number)&#xA;{&#xA;    int i=1;&#xA;    long factorial=1;&#xA;&#xA;    for(i=1;i&amp;lt;=number;i++)&#xA;    {&#xA;        factorial = factorial * i; &#xA;    }&#xA;    return factorial;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="1326351" LastActivityDate="2012-04-11T13:08:50.277" Title="How can i extend data type in java" Tags="&lt;java&gt;" AnswerCount="2" CommentCount="2" />
  <row Id="10355391" PostTypeId="1" AcceptedAnswerId="10355418" CreationDate="2012-04-27T17:44:58.170" Score="0" ViewCount="178" Body="&lt;p&gt;I am studying old examination papers from my university to be able to prepare for my upcoming exams. Everything is easily understandable from the simplest problems to the most complicated ones. However, I can not, for the life of me, figure the following one out.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class k{&#xA;    static int g(int n) {&#xA;        if (n==0){&#xA;            return 1;&#xA;        } else {&#xA;            return 2*g(n-1);&#xA;        }&#xA;    }&#xA;    public static void main(String[] args) {&#xA;        System.out.println(g(3));&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Why does this code return 8 as an answer. I get that its basically a power function where the number input is calculated as 2 to the power of that number and hence the answer in this case is 8. But what is really going on. I don't get it. Could someone please explain it in simple English? I'd really appreciate it.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;By the way, the question only asks what the output is, not why. But I would feel more comfortable if I knew why it is the way it is.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;PS: The reason people are giving answers using 5 as an example is that I had mistakenly put 5 instead of 3 in the code above, which I have corrected now.&lt;/p&gt;&#xA;" OwnerUserId="1105759" LastEditorUserId="488657" LastEditDate="2013-01-25T20:15:43.627" LastActivityDate="2013-01-25T20:15:43.627" Title="Recursion - Can't Understand This Simple Arithmetic in Java" Tags="&lt;java&gt;&lt;recursion&gt;" AnswerCount="5" CommentCount="4" />
  <row Id="10355504" PostTypeId="2" ParentId="10355391" CreationDate="2012-04-27T17:53:28.100" Score="1" Body="&lt;p&gt;It's a recursive function that takes a little piece of the arithmetic at a time, and sends along the rest until some ending condition is met.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Take, for instance, the well-known factorial recursive method.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public long factorial(int n) {&#xA;     return n == 0 ? 1 : n * factorial(n-1)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;If we call &lt;code&gt;factorial(3)&lt;/code&gt;, we need to do the following.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;factorial(3) =&amp;gt; 3 * factorial(3-1) =&amp;gt; 3 * 2 * factorial(2-1) =&amp;gt; 3 * 2 * 1 * factorial(1-1)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;You can see the recursive expansion from here.  Apply this similar tactic to your snippet of code, and you will arrive at why the answer is the way it is.&lt;/p&gt;&#xA;" OwnerUserId="1079354" LastActivityDate="2012-04-27T17:53:28.100" CommentCount="0" />
  <row Id="11171648" PostTypeId="1" AcceptedAnswerId="11171715" CreationDate="2012-06-23T17:43:39.067" Score="1" ViewCount="5226" Body="&lt;p&gt;I was making my way through project Euler, and I came across a combination problem. Combination logic means working out factorials. So, I decided to create a factorial method. And then I hit upon a problem - since I could quite easily use both iteration and recursion to do this, which one should I go for? I quickly wrote 2 methods - iterative:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public static long factorial(int num) {&#xA;        long result = 1;&#xA;        if(num == 0) {&#xA;            return 1;&#xA;        }&#xA;        else {&#xA;            for(int i = 2; i &amp;lt;= num; i++) {&#xA;                result *= i;&#xA;            }&#xA;            return result;&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;and recursive:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public static long factorial(int num) {&#xA;        if(num == 0) {&#xA;            return 1;&#xA;        }&#xA;        else {&#xA;            return num * factorial(num - 1);&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;If I am (obviously) talking about speed and functionality here, which one should I use? And, in general, is one of the techniques generally better than the other (so if I come across this choice later, what should I go for)?&lt;/p&gt;&#xA;" OwnerUserId="1175276" LastActivityDate="2012-06-24T03:41:37.247" Title="Factorial method - recursive or iterative? (Java)" Tags="&lt;java&gt;&lt;recursion&gt;&lt;iteration&gt;&lt;project-euler&gt;" AnswerCount="3" CommentCount="7" />
  <row Id="11446973" PostTypeId="1" AcceptedAnswerId="11447287" CreationDate="2012-07-12T07:29:43.077" Score="2" ViewCount="3099" Body="&lt;p&gt;I tried to find the factorial of a large number e.g. 8785856 in a typical way using for-loop and double data type.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But it is displaying infinity as the result, may be because it is exceeding its limit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So please guide me the way to find the factorial of a very large number.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My code:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class abc&#xA;{&#xA;    public static void main (String[]args)&#xA;    {&#xA;        double fact=1;&#xA;        for(int i=1;i&amp;lt;=8785856;i++)&#xA;        {&#xA;            fact=fact*i;&#xA;        }&#xA;&#xA;        System.out.println(fact);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Output:-&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Infinity&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;I am new to Java but have learned some concepts of IO-handling and all.&lt;/p&gt;&#xA;" OwnerUserId="1488014" LastEditorUserId="1288" LastEditDate="2012-10-05T16:30:13.620" LastActivityDate="2012-10-05T16:30:13.620" Title="Find factorial of large numbers in Java" Tags="&lt;java&gt;&lt;factorial&gt;&lt;largenumber&gt;" AnswerCount="6" CommentCount="6" />
  <row Id="11447287" PostTypeId="2" ParentId="11446973" CreationDate="2012-07-12T07:50:06.923" Score="0" Body="&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {&#xA;    BigInteger fact = BigInteger.valueOf(1);&#xA;    for (int i = 1; i &amp;lt;= 8785856; i++)&#xA;        fact = fact.multiply(BigInteger.valueOf(i));&#xA;    System.out.println(fact);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="1411866" LastActivityDate="2012-07-12T07:50:06.923" CommentCount="5" />
  <row Id="12770271" PostTypeId="1" CreationDate="2012-10-07T15:46:37.703" Score="0" ViewCount="220" Body="&lt;p&gt;Why I am not getting any Exception in the following code? &#xA;After running this code I am getting an infinite loop mentioning at test.fact(t.java:32)&#xA; No Compile-Time Error was found.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class test&#xA;{&#xA;&#xA;    int fact(int m) throws Exception&#xA;    {&#xA;        if (m==1)&#xA;        {&#xA;        return 1;&#xA;        }&#xA;    else&#xA;        return (fact ((m-1)*m));&#xA;    }&#xA;}&#xA;&#xA;class main&#xA;{&#xA;    public static void main(String ar[]) throws Exception&#xA;    {&#xA;        test t = new test();&#xA;        System.out.println(t.fact(5));&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;while say for example i am using &lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;return(a+b); &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;it executes successfully whats the problem with the recursion&#xA;to show an error???&lt;/p&gt;&#xA;" OwnerUserId="1726403" LastEditorUserId="1726403" LastEditDate="2012-10-07T15:56:24.633" LastActivityDate="2012-10-07T16:17:06.853" Title="Factorial recursion Exception not given in java 1.6" Tags="&lt;java&gt;&lt;exception&gt;&lt;recursion&gt;&lt;factorial&gt;&lt;throws&gt;" AnswerCount="3" CommentCount="13" />
  <row Id="14963551" PostTypeId="1" AcceptedAnswerId="14963619" CreationDate="2013-02-19T17:19:25.540" Score="-1" ViewCount="310" Body="&lt;p&gt;I am relatively new to programming, but I am trying to write a program that converts a number from base 10 to factorial base in order to assist me with a more challenging problem. Factorial base represents a number as the sum of factorials; for instance, 19 (base 10) = 301 (base factorial), because 3*3!+0*2!+1*1!=19. You can see a better explanation than mine at &lt;a href=&quot;http://en.wikipedia.org/wiki/Factorial_number_system&quot; rel=&quot;nofollow&quot;&gt;http://en.wikipedia.org/wiki/Factorial_number_system&lt;/a&gt;. What is the simplest way of accomplishing this for a number you can input? So far, I have been able to simply print the factorial of every number less than 10:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;for (int base = 1; base &amp;lt; 10; base++){&#xA;    int factorial = 1;&#xA;    for (int i = 1; i &amp;lt; base; i++){&#xA;        factorial = factorial*i;}&#xA;    System.out.println(factorial);}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;I am sure I am making numerous beginner mistakes; but I greatly appreciate any help you can give me for this. Thank you for your time, and for any assistance you can provide.&lt;/p&gt;&#xA;" OwnerUserId="2049256" LastEditorUserId="2049256" LastEditDate="2013-02-19T17:25:54.850" LastActivityDate="2013-02-19T19:15:03.157" Title="Java - Factorial Base Conversion" Tags="&lt;java&gt;&lt;loops&gt;&lt;for-loop&gt;&lt;factorial&gt;" AnswerCount="2" CommentCount="6" />
  <row Id="14963670" PostTypeId="2" ParentId="14963551" CreationDate="2013-02-19T17:25:28.963" Score="2" Body="&lt;p&gt;Try this &lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public int convertToFactorial(int x10){&#xA;    int length = String.valueOf(x10).length();&#xA;        String[] vals = String.valueOf(x10).split(&quot;&quot;);&#xA;&#xA;        int result = 0;&#xA;        for (int base = 1; base &amp;lt; length + 1; base++){&#xA;            int factorial = 1;&#xA;            for (int i = vals.length - base; i &amp;gt; 0; i--){&#xA;                factorial = factorial*i;&#xA;            }&#xA;            result += Integer.parseInt(vals[base]) * factorial;&#xA;        }&#xA;        System.out.println(result);&#xA;     return result;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;P.s. look at java code convention ant language structures, you shouldn't write ; after loop defenition.&lt;/p&gt;&#xA;" OwnerUserId="1201415" LastEditorUserId="1201415" LastEditDate="2013-02-19T17:57:48.247" LastActivityDate="2013-02-19T17:57:48.247" CommentCount="2" />
  <row Id="14992138" PostTypeId="1" CreationDate="2013-02-20T22:27:31.820" Score="0" ViewCount="1274" Body="&lt;pre&gt;&lt;code&gt;public class Prod {&#xA;    public static void main(String[] args) {&#xA;        System.out.println(prod(1, 4));&#xA;    }&#xA;    public static int prod(int m, int n) {&#xA;        if (m == n) {&#xA;            return n;&#xA;        } else {&#xA;            int recurse = prod(m, n-1);&#xA;            int result = n * recurse;&#xA;            return result;&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;On running the above code , I get 24 ?&#xA;I don't quite understand how?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My doubts:&#xA;1. When m =1 , n=4 , we call prod until m and n become equal to 1.&#xA;Then the output should be n and else block should not be executed??&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Someone please help me understand the logic.&lt;/p&gt;&#xA;" OwnerDisplayName="ShGulia" LastActivityDate="2013-02-21T00:03:05.813" Title="JAVA Recursive Program logic" Tags="&lt;java&gt;&lt;recursion&gt;" AnswerCount="3" CommentCount="0" />
  <row Id="14992292" PostTypeId="2" ParentId="14992138" CreationDate="2013-02-21T00:03:05.813" Score="0" Body="&lt;pre&gt;&lt;code&gt;prod(1, 4);&#xA;&#xA;public static int prod(int m, int n) {&#xA;    if (m == n) {&#xA;        return n;&#xA;    } else {&#xA;        int recurse = prod(m, n-1);&#xA;        int result = n * recurse;&#xA;        return result;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;can be transformed with m == 1 to:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;prodA(4);&#xA;public static int prodA(int n) {&#xA;    if (1 == n) {&#xA;        return n;&#xA;    } else {&#xA;        int recurse = prodA(n-1);&#xA;        int result = n * recurse;&#xA;        return result;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;which has a transformation (head recursion):&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public static int prodA(int n) {&#xA;    int result = 1;&#xA;    while (n &amp;gt; 1) { // Actually n != 1&#xA;        result *= n;&#xA;        --n;&#xA;    }&#xA;    return result;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;which is the factorial function.&lt;/p&gt;&#xA;" OwnerUserId="984823" LastActivityDate="2013-02-21T00:03:05.813" CommentCount="0" />
  <row Id="15107222" PostTypeId="1" CreationDate="2013-02-27T08:22:36.880" Score="-1" ViewCount="1717" Body="&lt;p&gt;Teaching myself Java. I have reached the recursion stage. How does this code work?&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;void myMethod( int counter)&#xA;{&#xA;if(counter == 0)&#xA; return;&#xA;else&#xA;   {&#xA;   System.out.println(&quot;&quot;+counter);&#xA;   myMethod(--counter);&#xA;   return;&#xA;   }&#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="2114468" LastEditorUserId="1228" LastEditDate="2013-08-22T20:47:01.447" LastActivityDate="2013-08-22T20:47:01.447" Title="Learning recursion in Java" Tags="&lt;java&gt;&lt;recursion&gt;" AnswerCount="6" CommentCount="5" ClosedDate="2013-07-23T06:14:54.863" />
  <row Id="15107520" PostTypeId="2" ParentId="15107222" CreationDate="2013-02-27T08:40:11.880" Score="0" Body="&lt;p&gt;A popular example when dealing with recursion is the calculation of a factorial.  We can use recursion effectively because of the observed pattern that:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;6! = 6 x 5!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;5! = 5 x 4! etc....&lt;/p&gt;&#xA;&#xA;&lt;p&gt;n! = n x (n - 1)!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we create a method to calculate the factorial we can see that pattern in practice.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private static int recursiveFactorial( final int num )&#xA;{&#xA;    if ( num == 1 ) //This is our termination condition, 1! = 1&#xA;    {&#xA;        return 1;&#xA;    }&#xA;&#xA;    else //else we put our n x (n-1)! rule into practice.&#xA;    {&#xA;        return num * recursiveFactorial( num - 1 );&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="1731714" LastActivityDate="2013-02-27T08:40:11.880" CommentCount="0" />
  <row Id="15808205" PostTypeId="1" AcceptedAnswerId="15808294" CreationDate="2013-04-04T10:04:38.290" Score="2" ViewCount="447" Body="&lt;p&gt;I am supposed to create a program that asks the user for a number and takes the factorial of that number then asks if they want to do another factorial (Y,N).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is supposed to work like this:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Enter a number to take the factorial of: 4&lt;/li&gt;&#xA;&lt;li&gt;4! = 24&lt;/li&gt;&#xA;&lt;li&gt;Do another factorial (Y,N)? Y&lt;/li&gt;&#xA;&lt;li&gt;Repeat until N is entered&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;My output is like:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Enter a number to take the factorial of: &lt;/li&gt;&#xA;&lt;li&gt;&quot;Do another factorial? (Y,N)?&quot;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;4! = 1 regardless of whether I enter Y or N.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here's my code:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import java.util.Scanner;&#xA;public class factorial&#xA;{&#xA;     public static void main ( String [] args )&#xA;     {&#xA;     Scanner input = new Scanner(System.in);&#xA;     System.out.print(&quot;Enter a number you want to take the factorial of: &quot;);&#xA;     int num = input.nextInt();&#xA;     int fact = 1;&#xA;     System.out.printf(&quot;%d! = %d\n &quot;, num, fact, Factorial(num, fact));&#xA; } &#xA;     public static int Factorial(int num, int fact)&#xA;     {&#xA;         Scanner input = new Scanner(System.in);&#xA;         char foo;&#xA;&#xA;          System.out.print(&quot;Do another factorial (Y,N)?&quot;);&#xA;          foo = input.next().charAt(0);&#xA;&#xA;             for (int i = 1; i &amp;gt;= num; i++)&#xA;             {   &#xA;                 fact *= i;&#xA;                 if (foo == 'Y')&#xA;                 {&#xA;                     System.out.print(&quot;Do another factorial (Y,N)?&quot;);&#xA;                     foo = input.next().charAt(0);&#xA;                     continue;&#xA;                 }&#xA;                 else&#xA;                 {&#xA;                     break;&#xA;                 }&#xA;             }&#xA;             return fact;  &#xA;&#xA;     }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;After the change:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import java.util.Scanner;&#xA;public class factorial&#xA;{&#xA;    public static void main ( String [] args )&#xA;    {&#xA;      Scanner input = new Scanner(System.in);&#xA;&#xA;        System.out.print(&quot;Enter a number you want to take the factorial of: &quot;);&#xA;        int num = input.nextInt();&#xA;&#xA;        int fact = 1;&#xA;&#xA;        System.out.printf(&quot;%d! = %d\n &quot;, num, Factorial(num, fact));&#xA;&#xA;        System.out.print(&quot;Do another factorial (Y,N)? &quot;);&#xA;        char  foo = input.next().charAt(0);&#xA;&#xA;        while (foo != 'N')&#xA;        {&#xA;            System.out.print(&quot;Do another factorial (Y,N)? &quot;);&#xA;            foo = input.next().charAt(0);&#xA;&#xA;        System.out.print(&quot;Enter a number you want to take the factorial of: &quot;);&#xA;        num = input.nextInt();&#xA;&#xA;        System.out.printf(&quot;%d! = %d\n&quot;, num, Factorial(num, fact));&#xA;    }&#xA;}&#xA;    public static int Factorial(int num, int fact)&#xA;    {&#xA;        for (int i = 1; i &amp;lt;= num; i++)&#xA;            {   &#xA;                fact *= i;&#xA;            }&#xA;            return fact; &#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Output still has some problems:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Enter a number to take the factorial of: 4&lt;/li&gt;&#xA;&lt;li&gt;4! = 24&lt;/li&gt;&#xA;&lt;li&gt;Do another factorial (Y,N)? Y&lt;/li&gt;&#xA;&lt;li&gt;Do another factorial (Y,N)? Y&lt;/li&gt;&#xA;&lt;li&gt;Enter a number to take the factorial of: 4&lt;/li&gt;&#xA;&lt;li&gt;4! = 24&lt;/li&gt;&#xA;&lt;li&gt;Do another factorial (Y,N)? N&lt;/li&gt;&#xA;&lt;li&gt;Enter a number to take the factorial of: &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="1858350" LastEditorUserId="1858350" LastEditDate="2013-04-04T10:59:48.447" LastActivityDate="2013-04-04T10:59:48.447" Title="Java factorial output" Tags="&lt;java&gt;&lt;output&gt;&lt;factorial&gt;" AnswerCount="5" CommentCount="0" />
  <row Id="15808944" PostTypeId="2" ParentId="15808205" CreationDate="2013-04-04T10:44:05.727" Score="0" Body="&lt;p&gt;This will help you.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public static void main ( String [] args )&#xA;     {&#xA;     String yesno =&quot;Y&quot;;&#xA;     while(yesno.equalsIgnoreCase(&quot;y&quot;))&#xA;     {&#xA;         Scanner input = new Scanner(System.in);&#xA;         System.out.print(&quot;Enter a number you want to take the factorial of: &quot;);&#xA;         int num = input.nextInt();&#xA;         System.out.printf(&quot;%d! = %d\n &quot;,num,fact(num));&#xA;         System.out.print(&quot;Do another factorial (Y,N)?&quot;);&#xA;         Scanner inputKey = new Scanner(System.in);&#xA;         yesno = inputKey.nextLine();&#xA;&#xA;     }&#xA;     }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Here is factorial function:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public static int fact(int num)&#xA;    {&#xA;        if(num&amp;lt;=1)&#xA;        {&#xA;            return 1;&#xA;&#xA;        }else{&#xA;            return (num*(fact(num-1))); &#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="637517" LastActivityDate="2013-04-04T10:44:05.727" CommentCount="0" />
  <row Id="16212476" PostTypeId="1" AcceptedAnswerId="16212542" CreationDate="2013-04-25T10:34:44.300" Score="-4" ViewCount="628" Body="&lt;p&gt;poCould anyone explain this piece of code to me?? Its a power function using iteration&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  public static int iterate(int a, int n) &#xA;{&#xA;    int i ;&#xA;    int result = 1 ;&#xA;&#xA;    for(i = 0 ; i &amp;lt; n ; i++){&#xA;        result = result*a ;              &#xA;    }&#xA;    return result ;&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="2319199" LastEditorUserId="2319199" LastEditDate="2013-04-25T10:54:06.633" LastActivityDate="2013-04-25T10:54:06.633" Title="Factorial iteration java" Tags="&lt;java&gt;&lt;iteration&gt;&lt;factorial&gt;" AnswerCount="1" CommentCount="3" ClosedDate="2013-04-25T12:28:18.323" />
  <row Id="18489976" PostTypeId="1" AcceptedAnswerId="18490406" CreationDate="2013-08-28T13:55:01.737" Score="0" ViewCount="106" Body="&lt;p&gt;I am doing a factorial question with java loop, it asks 1+1/2!+1/3!+...+1/n!, n is positive,&#xA;I am using &quot;while&quot; to make it, but the code is run with nothing ：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    public static void main(String[] args) {&#xA;&#xA;    double sum=0,a=1;&#xA;    int n=Integer.parseInt(args[0]);&#xA;    while(n&amp;gt;0){&#xA;&#xA;        a=a*n;&#xA;        sum=sum+1.0/a;&#xA;    }&#xA;    System.out.print(sum);&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;please help：）&lt;/p&gt;&#xA;" OwnerUserId="2715692" LastActivityDate="2013-08-28T14:19:29.250" Title="Java loop runs infinite" Tags="&lt;java&gt;&lt;while-loop&gt;" AnswerCount="4" CommentCount="2" />
  <row Id="18794667" PostTypeId="1" CreationDate="2013-09-13T20:25:57.817" Score="-7" ViewCount="131" Body="&lt;p&gt;Coding a recursive method in Java that calculates factorials. Unfortunately it's not working, and I suspect it's because of the 2 parameters that I wasn't too sure about -- which I surrounded with asterisks. Are those the correct parameters that belong there? Or do I need to change them to something else and why? Thanks in advance!&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public fact(n)&#xA;{&#xA;   return this.factHelp(n, ***n+1*** );&#xA;}&#xA;&#xA;private factHelp(n, result)&#xA;{&#xA;   if (n == 0)&#xA;      return result;&#xA;   else&#xA;      return this.factHelp(n – 1, ***result***);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="2777815" LastActivityDate="2013-09-13T20:36:27.490" Title="Recursive method in Java that calculates factorials not working" Tags="&lt;java&gt;&lt;math&gt;&lt;methods&gt;&lt;recursion&gt;&lt;factorial&gt;" AnswerCount="1" CommentCount="13" />
  <row Id="18794691" PostTypeId="2" ParentId="18794667" CreationDate="2013-09-13T20:27:24.920" Score="2" Body="&lt;p&gt;This code doesn't compile.  &lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;You're missing the return types on both of these methods.  You should use &lt;code&gt;public int fact...&lt;/code&gt; instead of &lt;code&gt;public fact...&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;Your parameters don't have types.  It should probably be &lt;code&gt;fact(int n)&lt;/code&gt; instead of &lt;code&gt;fact(n)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;You don't &lt;em&gt;need&lt;/em&gt; two functions to do this.  You can use two if you want, but I just wanted to let you know it's unnecessary.  &lt;/li&gt;&#xA;&lt;li&gt;You should probably google for &quot;recursive factorial algorithm&quot; to get more help.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="61624" LastEditorUserId="61624" LastEditDate="2013-09-13T20:36:27.490" LastActivityDate="2013-09-13T20:36:27.490" CommentCount="12" />
  <row Id="19073890" PostTypeId="2" ParentId="8183426" CreationDate="2013-09-29T02:48:29.567" Score="0" Body="&lt;p&gt;Although this is old, it still keeps coming up pretty well in google. So I figured I'd mention this. No one mentioned to check for when &lt;strong&gt;x = 0&lt;/strong&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;0! and 1! both = 1. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This isn't being checked with the previous answers, and would cause a stack overflow, if fact(0) was run. Anyway simple fix:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public static int fact(int x){&#xA;    if (x==1 | x==0)&#xA;        return 1;&#xA;    return fact(x-1) * x;&#xA;}// fact&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="597263" LastActivityDate="2013-09-29T02:48:29.567" CommentCount="0" />
  <row Id="19477830" PostTypeId="1" AcceptedAnswerId="19478106" CreationDate="2013-10-20T13:19:29.283" Score="1" ViewCount="96" Body="&lt;p&gt;Hi I am creating an app for android and I encountered a problem with how to color bitmaps&#xA;I am using the following simple code&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;for(int i=0;i&amp;lt;pixels.length;i++){&#xA;          if(pixels[i] == COLOR.WHITE){&#xA;           pixels[i]=Color.RED;&#xA;        }&#xA; }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Where pixels is the array of pixels of the bitmap &#xA;However the problem is that I'm getting in the edges of the colored area a thin layer of pixels that weren't colored I  understand this stems from that this layer of white is somewhat shadowy(not entirely white partially black) how do I get over this? &#xA;Hope I made my question clear enough &lt;/p&gt;&#xA;" OwnerUserId="2900110" LastActivityDate="2013-10-21T14:11:07.040" Title="Coloring bitmap with java" Tags="&lt;android&gt;" AnswerCount="1" CommentCount="2" />
  <row Id="19478106" PostTypeId="2" ParentId="19477830" CreationDate="2013-10-20T13:47:32.307" Score="1" Body="&lt;p&gt;Right now you are matching and replacing one specific integer value for white. However, in your original bitmap that white color bleeds into other colors and therefore you have white color values around the edges of these white patches that are slightly different. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;You need to change your algorithm to take a color matching tolerance into account. For that you'll have to split up your pixel and your key color into their three color channels and check them individually if the differences between them are within a certain tolerance value.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;That way you can match these whitish colored pixels around the edges. But even with added tolerance you cannot just replace your matching pixels just with red. You would get aliased hard, red edges and it wouldn't look pretty. I wrote a similar algorithm a while ago and got around that aliasing issue by doing some color blending in HSV color space:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public Bitmap changeColor(Bitmap src, int keyColor,&#xA;            int replColor, int tolerance) {&#xA;        Bitmap copy = src.copy(Bitmap.Config.ARGB_8888, true);&#xA;        int width = copy.getWidth();&#xA;        int height = copy.getHeight();&#xA;        int[] pixels = new int[width * height];&#xA;        src.getPixels(pixels, 0, width, 0, 0, width, height);&#xA;        int sR = Color.red(keyColor);&#xA;        int sG = Color.green(keyColor);&#xA;        int sB = Color.blue(keyColor);&#xA;        int tR = Color.red(replColor);&#xA;        int tG = Color.green(replColor);&#xA;        int tB = Color.blue(replColor);&#xA;        float[] hsv = new float[3];&#xA;        Color.RGBToHSV(tR, tG, tB, hsv);&#xA;        float targetHue = hsv[0];&#xA;        float targetSat = hsv[1];&#xA;        float targetVal = hsv[2];&#xA;&#xA;        for(int i = 0; i &amp;lt; pixels.length; ++i) {&#xA;            int pixel = pixels[i];&#xA;&#xA;            if(pixel == keyColor) {&#xA;                pixels[i] = replColor;&#xA;            } else {&#xA;                int pR = Color.red(pixel);&#xA;                int pG = Color.green(pixel);&#xA;                int pB = Color.blue(pixel);&#xA;&#xA;                int deltaR = Math.abs(pR - sR);&#xA;                int deltaG = Math.abs(pG - sG);&#xA;                int deltaB = Math.abs(pB - sB);&#xA;&#xA;                if(deltaR &amp;lt;= tolerance &amp;amp;&amp;amp; deltaG &amp;lt;= tolerance&#xA;                        &amp;amp;&amp;amp; deltaB &amp;lt;= tolerance) {&#xA;                    Color.RGBToHSV(pR, pG, pB, hsv);&#xA;                    hsv[0] = targetHue;&#xA;                    hsv[1] = targetSat;&#xA;                    hsv[2] *= targetVal;&#xA;&#xA;                    int mixTrgColor = Color.HSVToColor(Color.alpha(pixel),&#xA;                            hsv);&#xA;                    pixels[i] = mixTrgColor;&#xA;                }&#xA;            }&#xA;        }&#xA;&#xA;        copy.setPixels(pixels, 0, width, 0, 0, width, height);&#xA;&#xA;        return copy;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;keyColor and replColor are ARGB encoded integer values such as Color.WHITE and Color.RED. tolerance is a value from 0 to 255 that specifies the key color matching tolerance per color channel. I had to rewrite that snippet a bit to remove framework specifics. I hope I didn't make any mistakes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As a word of warning: Java (on Android) is pretty slow with image processing. If it's not fast enough for you, you should rewrite the algorithm in C for example and use the NDK.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;UPDATE: Color replace algorithm in C&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here is the implementation of the same algorithm written in C. The last function is the actual algorithm which takes the bitmap's pixel array as argument. You need to create a header file with that function declaration and set up some NDK compilation boilerplate and create an additional Java class with the following method declaration:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;native static void changeColor(int[] pixels, int width, int height, int keyColor, int replColor, int tolerance);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;C implementation:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;math.h&amp;gt;&#xA;&#xA;#define MIN(x,y) ((x &amp;lt; y) ? x : y)&#xA;#define MAX(x,y) ((x &amp;gt; y) ? x : y)&#xA;&#xA;int clamp_byte(int val) {&#xA;    if(val &amp;gt; 255) {&#xA;        return 255;&#xA;    } else if(val &amp;lt; 0) {&#xA;        return 0;&#xA;    } else {&#xA;        return val;&#xA;    }&#xA;}&#xA;&#xA;int encode_argb(uint8_t r, uint8_t g, uint8_t b, uint8_t a) {&#xA;    return ((a &amp;amp; 0xFF) &amp;lt;&amp;lt; 24) | ((r &amp;amp; 0xFF) &amp;lt;&amp;lt; 16) | ((g &amp;amp; 0xFF) &amp;lt;&amp;lt; 8) | (b &amp;amp; 0xFF);&#xA;}&#xA;&#xA;int alpha(int c) {&#xA;    return (c &amp;gt;&amp;gt; 24) &amp;amp; 0xFF;&#xA;}&#xA;&#xA;int red(int c) {&#xA;    return (c &amp;gt;&amp;gt; 16) &amp;amp; 0xFF;&#xA;}&#xA;&#xA;int green(int c) {&#xA;    return (c &amp;gt;&amp;gt; 8) &amp;amp; 0xFF;&#xA;}&#xA;&#xA;int blue(int c) {&#xA;    return c &amp;amp; 0xFF;&#xA;}&#xA;&#xA;typedef struct struct_hsv {&#xA;    uint16_t h;&#xA;    uint8_t s;&#xA;    uint8_t v;&#xA;} hsv;&#xA;&#xA;// http://www.ruinelli.ch/rgb-to-hsv&#xA;hsv rgb255_to_hsv(uint8_t r, uint8_t g, uint8_t b) {&#xA;    uint8_t min, max, delta;&#xA;    hsv result;&#xA;    int h;&#xA;&#xA;    min = MIN(r, MIN(g, b));&#xA;    max = MAX(r, MAX(g, b));&#xA;&#xA;    result.v = max; // v, 0..255&#xA;    delta = max - min; // 0..255, &amp;lt; v&#xA;&#xA;    if(delta != 0 &amp;amp;&amp;amp; max != 0) {&#xA;        result.s = ((int) delta) * 255 / max; // s, 0..255&#xA;&#xA;        if(r == max) {&#xA;            h = (g - b) * 60 / delta; // between yellow &amp;amp; magenta&#xA;        } else if(g == max) {&#xA;            h = 120 + (b - r) * 60 / delta; // between cyan &amp;amp; yellow&#xA;        } else {&#xA;            h = 240 + (r - g) * 60 / delta; // between magenta &amp;amp; cyan&#xA;        }&#xA;&#xA;        if(h &amp;lt; 0) h += 360;&#xA;&#xA;        result.h = h;&#xA;    } else {&#xA;        // r = g = b = 0&#xA;        result.h = 0;&#xA;        result.s = 0;&#xA;    }&#xA;&#xA;    return result;&#xA;}&#xA;&#xA;int hsv_to_argb(hsv color, uint8_t alpha) {&#xA;    int i;&#xA;    uint8_t r,g,b;&#xA;    float f, p, q, t, h, s, v;&#xA;&#xA;    h = (float) color.h;&#xA;    s = (float) color.s;&#xA;    v = (float) color.v;&#xA;&#xA;    s /= 255;&#xA;&#xA;    if(s == 0) {&#xA;        // achromatic (grey)&#xA;        return encode_argb(color.v, color.v, color.v, alpha);&#xA;    }&#xA;&#xA;    h /= 60; // sector 0 to 5&#xA;    i = floor(h);&#xA;    f = h - i; // factorial part of h&#xA;    p = (unsigned char) (v * (1 - s));&#xA;    q = (unsigned char) (v * (1 - s * f));&#xA;    t = (unsigned char) (v * (1 - s * (1 - f)));&#xA;&#xA;    switch(i) {&#xA;        case 0:&#xA;            r = v;&#xA;            g = t;&#xA;            b = p;&#xA;            break;&#xA;        case 1:&#xA;            r = q;&#xA;            g = v;&#xA;            b = p;&#xA;            break;&#xA;        case 2:&#xA;            r = p;&#xA;            g = v;&#xA;            b = t;&#xA;            break;&#xA;        case 3:&#xA;            r = p;&#xA;            g = q;&#xA;            b = v;&#xA;            break;&#xA;        case 4:&#xA;            r = t;&#xA;            g = p;&#xA;            b = v;&#xA;            break;&#xA;        default: // case 5:&#xA;            r = v;&#xA;            g = p;&#xA;            b = q;&#xA;            break;&#xA;    }&#xA;&#xA;    return encode_argb(r, g, b, alpha);&#xA;}&#xA;&#xA;JNIEXPORT void JNICALL Java_my_package_name_ClassName_changeColor(&#xA;        JNIEnv* env, jclass clazz, jintArray bitmapArray, jint width, jint height,&#xA;        jint keyColor, jint replColor, jint tolerance) {&#xA;    jint* pixels = (*env)-&amp;gt;GetPrimitiveArrayCritical(env, bitmapArray, 0);&#xA;    int sR = red(keyColor);&#xA;    int sG = green(keyColor);&#xA;    int sB = blue(keyColor);&#xA;    int tR = red(replColor);&#xA;    int tG = green(replColor);&#xA;    int tB = blue(replColor);&#xA;    hsv cHsv = rgb255_to_hsv(tR, tG, tB);&#xA;    int targetHue = cHsv.h;&#xA;    int targetSat = cHsv.s;&#xA;    int targetVal = cHsv.v;&#xA;    int i;&#xA;    int max = width * height;&#xA;&#xA;    for(i = 0; i &amp;lt; max; ++i) {&#xA;        int pixel = pixels[i];&#xA;&#xA;        if(pixel == keyColor) {&#xA;            pixels[i] = replColor;&#xA;        } else {&#xA;            int pR = red(pixel);&#xA;            int pG = green(pixel);&#xA;            int pB = blue(pixel);&#xA;&#xA;            int deltaR = abs(pR - sR);&#xA;            int deltaG = abs(pG - sG);&#xA;            int deltaB = abs(pB - sB);&#xA;&#xA;            if(deltaR &amp;lt;= tolerance &amp;amp;&amp;amp; deltaG &amp;lt;= tolerance&#xA;                    &amp;amp;&amp;amp; deltaB &amp;lt;= tolerance) {&#xA;                cHsv = rgb255_to_hsv(pR, pG, pB);&#xA;                cHsv.h = targetHue;&#xA;                cHsv.s = targetSat;&#xA;                int newValue = ((int) cHsv.v * targetVal) / 255;&#xA;                cHsv.v = newValue;&#xA;&#xA;                int mixTrgColor = hsv_to_argb(cHsv, alpha(pixel));&#xA;                pixels[i] = mixTrgColor;&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    (*env)-&amp;gt;ReleasePrimitiveArrayCritical(env, bitmapArray, pixels, 0);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="1473663" LastEditorUserId="1473663" LastEditDate="2013-10-21T14:11:07.040" LastActivityDate="2013-10-21T14:11:07.040" CommentCount="3" />
  <row Id="19532553" PostTypeId="1" AcceptedAnswerId="19532602" CreationDate="2013-10-23T04:03:43.693" Score="1" ViewCount="947" Body="&lt;p&gt;For my programming class I have to make a program that calculates the combinations function C(n,k) = n!/(k!*(n-k)!) by using a main method to deal with input/output, a method to compute the factorial, and a method to compute the combinations function. Here's my code:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import java.util.Scanner;&#xA;public class Combinations {&#xA;&#xA;    public static void factorials (int set, int objects) {&#xA;        Scanner keyboard = new Scanner(System.in);&#xA;        int n = set;&#xA;        int k = objects;&#xA;        int c = (n-k);&#xA;        int factorial1 = 1;&#xA;        int factorial2 = 1;&#xA;        int factorial3 = 1;&#xA;        while (n &amp;gt; 0) {&#xA;            factorial1 = factorial1 + s;&#xA;            n = n++;&#xA;        }//while loop&#xA;        while (k &amp;gt; 0) {&#xA;            factorial2 = factorial2 + o;&#xA;            k = k++;&#xA;        }//while loop&#xA;        while (c &amp;gt; 0) {&#xA;            factorial3 = factorial3 + c;&#xA;            c = c++;&#xA;        }//while loop&#xA;        System.out.println(Combinations(factorial1,factorial2,factorial3));&#xA;    }//method factorials&#xA;    public static int Combinations (int set, int objects, int x){&#xA;        int n = set;&#xA;        int k = objects;&#xA;        int c = x;&#xA;        int combination;&#xA;        combination = n/(k*c);&#xA;        return combination;&#xA;    }//method Combinations&#xA;    public static void main(String[] args) {&#xA;        Scanner keyboard = new Scanner(System.in);&#xA;        System.out.println(&quot;Enter the number of integers in a set: &quot;);&#xA;        int n = keyboard.nextInt();&#xA;        System.out.println(&quot;Enter the number of objects to be chosen from the set: &quot;);&#xA;        int k = keyboard.nextInt();&#xA;        System.out.println(factorials(n,k));&#xA;    }//method main&#xA;&#xA;}//class&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;My problem is that I'm getting an error message for &lt;code&gt;System.out.println(factorials(s,o));&lt;/code&gt; - &quot;The method println(boolean) in the type PrintStream is not applicable for the arguments (void)&quot;. I have no idea why it's saying this. Help? &lt;/p&gt;&#xA;" OwnerUserId="2905631" LastEditorUserId="2905631" LastEditDate="2013-10-23T04:11:27.243" LastActivityDate="2013-10-23T05:47:28.300" Title="Java program to calculate the combinations function" Tags="&lt;java&gt;&lt;methods&gt;&lt;combinations&gt;&lt;factorial&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="19532602" PostTypeId="2" ParentId="19532553" CreationDate="2013-10-23T04:08:42.277" Score="0" Body="&lt;p&gt;In your code,&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public static void factorials(int set, int objects)&#xA;{&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;returns &lt;code&gt;void&lt;/code&gt;. you cannot use &lt;code&gt;void&lt;/code&gt; method in &#xA;&lt;code&gt;System.out.println(factorials(s, o));&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;try chaning your code as&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public static int factorials(int set, int objects)&#xA;{&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;another way to calculate combinations without method calling,&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;        int index, numberOfItems, itemsToBeSelected, combinations;&#xA;        int factorial, temp, result;&#xA;&#xA;        Scanner scanner = new Scanner(System.in);&#xA;        System.out.println(&quot;Number Of Items (n) : &quot;);&#xA;        numberOfItems = scanner.nextInt();&#xA;&#xA;        System.out.println(&quot;Items to be selected (r): &quot;);&#xA;        itemsToBeSelected = scanner.nextInt();&#xA;&#xA;&#xA;        for (index = 1, factorial = 1; index &amp;lt;= numberOfItems; index++)    /* Calculate (numberOfItems) -&amp;gt; n! */&#xA;        {&#xA;            factorial = factorial * index;&#xA;        }&#xA;&#xA;        for (index = 1, temp = 1; index &amp;lt;= itemsToBeSelected; index++)         /* Calculate (itemsToBeSelected) -&amp;gt; r! */&#xA;        {&#xA;            temp = temp * index;&#xA;        }&#xA;&#xA;        for (index = 1, result = 1; index &amp;lt;= (numberOfItems - itemsToBeSelected); index++) /* Calculate (numberOfItems - itemsToBeSelected) -&amp;gt; (n-r)!*/&#xA;        {&#xA;            result = result * index;&#xA;        }&#xA;&#xA;        combinations = factorial / (temp * result);&#xA;        System.out.println(&quot;Combinations : &quot; + numberOfItems + &quot;C&quot; + itemsToBeSelected + &quot; : &quot; + combinations);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Number Of Items (n) : &#xA;8&#xA;Items to be selected (r): &#xA;3&#xA;Combinations : 8C3 : 56&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="1793799" LastEditorUserId="1793799" LastEditDate="2013-10-23T05:47:28.300" LastActivityDate="2013-10-23T05:47:28.300" CommentCount="3" />
  <row Id="19787441" PostTypeId="1" AcceptedAnswerId="19787471" CreationDate="2013-11-05T11:01:51.220" Score="-5" ViewCount="144" Body="&lt;p&gt;I am printing the factorial of the first 10 numbers, so it is 0 - 9. The below code works for me. But I am unable to make the loop such that the factorial of 0 is within the loop too. Any advice is appreciated. Thank you. &lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class fact {&#xA;&#xA;    public static void main(String[] args) { &#xA;        System.out.println(&quot;\n\n(f) Loop to print first 10 factorial numbers&quot;);&#xA;&#xA;        System.out.println(&quot;\nFactorial of 0 is 1&quot;);&#xA;&#xA;        int fact = 1; &#xA;        int index = 1; &#xA;        while (index &amp;lt; 10) &#xA;&#xA;        { &#xA;            fact*=index; &#xA;            System.out.println(&quot;Factorial of &quot; + index + &quot; is &quot; + fact); &#xA;            index++; &#xA;        } &#xA;    }&#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="2840178" LastActivityDate="2013-11-05T11:47:53.897" Title="Java - Factorial" Tags="&lt;java&gt;" AnswerCount="4" CommentCount="0" FavoriteCount="0" />
  <row Id="19787637" PostTypeId="2" ParentId="19787441" CreationDate="2013-11-05T11:12:15.943" Score="0" Body="&lt;pre&gt;&lt;code&gt;factorialList(10);&#xA;&#xA;public static int factorialList(int indexMax) {&#xA;    int fact = 1;&#xA;    if (indexMax &amp;gt; 0) fact = indexMax * factorialList(indexMax - 1);&#xA;    System.out.println(&quot;Factorial of &quot; + indexMax + &quot; is &quot; + fact);&#xA;    return fact;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Fn calls are less effective than loops but I bet it would be optimized to ~ the same on task of this size.&lt;/p&gt;&#xA;" OwnerUserId="1420427" LastEditorUserId="1420427" LastEditDate="2013-11-05T11:29:11.113" LastActivityDate="2013-11-05T11:29:11.113" CommentCount="2" />
  <row Id="20055826" PostTypeId="2" ParentId="891031" CreationDate="2013-11-18T19:10:33.317" Score="1" Body="&lt;p&gt;A very simple method to calculate factorials:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private double FACT(double n) {&#xA;    double num = n;&#xA;    double total = 1;&#xA;    if(num != 0 | num != 1){&#xA;        total = num;&#xA;    }else if(num == 1 | num == 0){&#xA;        total = 1;&#xA;    }&#xA;    double num2;&#xA;    while(num &amp;gt; 1){&#xA;        num2 = num - 1;&#xA;        total = total * num2;&#xA;        num = num - 1;&#xA;    }&#xA;    return total;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;I have used double because they can hold massive numbers, but you can use any other type like int, long, float, etc.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;P.S. This might not be the best solution but I am new to coding and it took me ages to find a simple code that could calculate factorials so I had to write the method myself but I am putting this on here so it helps other people like me.&lt;/p&gt;&#xA;" OwnerUserId="3005960" LastActivityDate="2013-11-18T19:10:33.317" CommentCount="0" />
  <row Id="21150190" PostTypeId="1" AcceptedAnswerId="21150228" CreationDate="2014-01-15T23:06:46.270" Score="-1" ViewCount="156" Body="&lt;p&gt;Hi I need to print process of factorial calculation.&#xA;E.g. If the user's input is 5, the system should print out &quot;5 * 4 * 3 * 2 * 1 = 120&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I have this code:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt; public static void factorial()&#xA;{&#xA;    Scanner sc = new Scanner(System.in);&#xA;    int factorial = 1;&#xA;    int count;&#xA;&#xA;    System.out.println(me+&quot;, This is option 2: Calculate a factorial&quot;);&#xA;    System.out.print(&quot;Enter your number: &quot;);&#xA;    int number = sc.nextInt();&#xA;    System.out.println();&#xA;&#xA;    if (number&amp;gt;0)&#xA;        {&#xA;            for (count=1; count&amp;lt;=number; count++)&#xA;&#xA;            factorial = factorial*count;&#xA;&#xA;            System.out.println(&quot; = &quot;+factorial);&#xA;            System.out.println();&#xA;        }&#xA;    else&#xA;    {&#xA;        System.out.println(&quot;Enter a positive whole number greater than 0&quot;);&#xA;        System.out.println();&#xA;    } &#xA;&#xA;}    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;I have tried insert this code:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt; System.out.print(count+&quot; * &quot;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;But the output is &quot;1 * 2 * 3 * 4 * 5 *  = 6&quot;. So the result is wrong too.&#xA;How can I change the code?&#xA;Thanks&lt;/p&gt;&#xA;" OwnerUserId="2441860" LastEditorUserId="2441860" LastEditDate="2014-01-15T23:15:00.567" LastActivityDate="2014-01-15T23:18:07.887" Title="print factorial calculation process in java" Tags="&lt;java&gt;&lt;if-statement&gt;&lt;factorial&gt;" AnswerCount="3" CommentCount="4" />
  <row Id="21482785" PostTypeId="1" AcceptedAnswerId="21482860" CreationDate="2014-01-31T14:44:22.940" Score="-1" ViewCount="638" Body="&lt;p&gt;I want to do a factorial program in java using a for loop. For example I want to take the user input, lets say &lt;code&gt;10&lt;/code&gt;, and then multiply &lt;code&gt;10*9*8*7*6*5*4*3*2*1&lt;/code&gt;. I need help constructing the &lt;code&gt;for&lt;/code&gt; loop. The code below is all I have so far as I'm not sure where to go after.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import java.util.Scanner;&#xA;import java.lang.Math;&#xA;public class factorial {&#xA;&#xA;    public static void main(String[] args) {&#xA;        int num;&#xA;        Scanner input = new Scanner(System.in);&#xA;        System.out.println(&quot;Enter a number: &quot;);&#xA;        num = input.nextInt();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="3206766" LastEditorUserId="2317829" LastEditDate="2014-01-31T14:49:51.430" LastActivityDate="2014-01-31T15:00:33.793" Title="Factorial Java Program" Tags="&lt;java&gt;&lt;for-loop&gt;&lt;factorial&gt;" AnswerCount="3" CommentCount="3" />
  <row Id="21482860" PostTypeId="2" ParentId="21482785" CreationDate="2014-01-31T14:47:40.163" Score="0" Body="&lt;p&gt;Try&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {&#xA;    int num;&#xA;    int fact=1;&#xA;    Scanner input = new Scanner(System.in);&#xA;    System.out.println(&quot;Enter a number: &quot;);&#xA;    num = input.nextInt();&#xA;    for (int i=2;i&amp;lt;=num; i++){&#xA;        fact=fact*i;&#xA;    }&#xA;&#xA;    System.out.println(&quot;Factorial: &quot;+fact);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="3074592" LastEditorUserId="3074592" LastEditDate="2014-01-31T14:51:36.900" LastActivityDate="2014-01-31T14:51:36.900" CommentCount="8" />
  <row Id="21483111" PostTypeId="2" ParentId="21482785" CreationDate="2014-01-31T15:00:33.793" Score="0" Body="&lt;p&gt;Why bother computing it?&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public int factorial ( int n ) {&#xA;switch(n){&#xA;case 0: return 1;&#xA;case 1: return 1;&#xA;case 2: return 2;&#xA;case 3: return 6;&#xA;case 4: return 24;&#xA;case 5: return 120;&#xA;case 6: return 720;&#xA;case 7: return 5040;&#xA;case 8: return 40320;&#xA;case 9: return 362880;&#xA;case 10: return 3628800;&#xA;case 11: return 39916800;&#xA;case 12: return 479001600;&#xA;default : throw new IllegalArgumentException();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Source : &lt;a href=&quot;http://codegolf.stackexchange.com/a/16673/8806&quot;&gt;@Emory&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="2136410" LastActivityDate="2014-01-31T15:00:33.793" CommentCount="2" />
  <row Id="21704350" PostTypeId="1" CreationDate="2014-02-11T14:17:24.597" Score="0" ViewCount="69" Body="&lt;p&gt;Hi I am currently doing a piece of work for coursework. So I have done this code. However how can I stop it from returning number when &lt;code&gt;x number is &amp;lt; 0&lt;/code&gt;?&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class Factorial {&#xA;&#xA;    public Factorial() {&#xA;        System.out.print(new C1().computeFac(10));&#xA;    }      &#xA;&#xA;    /** First addicional class **/&#xA;    private class C1 {&#xA;&#xA;        /** Fields **/&#xA;        private int a,result = 1;&#xA;&#xA;        /** Method **/&#xA;        public int computeFac(int input) {&#xA;&#xA;            if (input &amp;lt; 0) {&#xA;                System.out.print(new C2().printError(0));&#xA;            } else {&#xA;&#xA;                for ( a = 1 ; a &amp;lt;= input ; a++ )&#xA;&#xA;                    result = result*a;&#xA;                return (result);&#xA;            } &#xA;            return (result);            &#xA;        }&#xA;    }&#xA;&#xA;    /** Second Addicional class **/&#xA;    private class C2 {&#xA;&#xA;        /** Fields **/&#xA;        String errosArray[] = {&quot;Negative numbers are not aceptable! \nPlease try again!\n&quot;};&#xA;&#xA;        public String printError(int a) {&#xA;            return errosArray[a];&#xA;        }&#xA;&#xA;    }&#xA;&#xA;    /** Main Method **/&#xA;    public static void main(String [ ] args) {&#xA;        Factorial factorial = new Factorial();&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="3287764" LastEditorUserId="237733" LastEditDate="2014-02-11T14:20:20.940" LastActivityDate="2014-02-11T14:23:34.207" Title="Factorial Class in Java" Tags="&lt;java&gt;&lt;factorial&gt;" AnswerCount="1" CommentCount="2" />
  <row Id="21704486" PostTypeId="2" ParentId="21704350" CreationDate="2014-02-11T14:23:34.207" Score="3" Body="&lt;p&gt;The normal approach would be to throw an exception at this point. So your code would look like:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;        public int computeFac(int input) {&#xA;            if (input &amp;lt; 0) {&#xA;                throw new IllegalArgumentException(&quot;Negative numbers are not allowed&quot;);&#xA;            }&#xA;            for ( a = 1 ; a &amp;lt;= input ; a++ ) {&#xA;                result = result*a;&#xA;            }&#xA;            return result;&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Also, note, that it's a good idea to always use braces for loops and conditionals, even if they only have one line.&lt;/p&gt;&#xA;" OwnerUserId="1837823" LastActivityDate="2014-02-11T14:23:34.207" CommentCount="2" />
  <row Id="22354050" PostTypeId="2" ParentId="891031" CreationDate="2014-03-12T14:06:09.193" Score="0" Body="&lt;pre&gt;&lt;code&gt;public static int fact(int i){&#xA;    if(i==0)&#xA;       return 0;&#xA;    if(i&amp;gt;1){&#xA;       i = i * fact(--i);&#xA;    }&#xA;&#xA;   return i;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="1133690" LastEditorUserId="1849664" LastEditDate="2014-03-25T23:27:17.697" LastActivityDate="2014-03-25T23:27:17.697" CommentCount="1" />
  <row Id="22539430" PostTypeId="1" AcceptedAnswerId="22539550" CreationDate="2014-03-20T16:34:25.347" Score="2" ViewCount="72" Body="&lt;p&gt;Can anyone help with my java factorial assignment? i think im doing it right but im not for sure. I need to have the user input a number and then calculate the factorials of the input number. Like is the person enter 10, the user would see this as an output:&#xA;0! = 1, 1! = 1, 2! = 2, 3! = 6, 4! = 24, 5! = 120, 6! = 720, 7! = 5040, 8! = 40320, 9! = 362880&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import java.lang.Math;&#xA;import java.util.Scanner;&#xA;&#xA;public class Factorial {&#xA;&#xA;public static int factorial( int iNo ) {&#xA;    if (iNo &amp;lt; 0) throw&#xA;        new IllegalArgumentException(&quot;iNo must be &amp;gt;= 0&quot;);&#xA;&#xA;    int factorial = 1;&#xA;    for(int i = 2 ; i &amp;lt;= iNo; i++)&#xA;        factorial *= i;&#xA;    System.out.println ( i + &quot;! = &quot; + factorial(i));&#xA;&#xA;    return factorial ;&#xA;}&#xA;}&#xA;public class Factorial{&#xA;    public static void main ( String args[] ){&#xA;        Scanner input = new Scanner (System.in);&#xA;        System.out.println(&quot;Enter number of factorials to calculate: &quot; );&#xA;        int  iNo = input.nextInt();&#xA;        for(int i = 0; i &amp;lt;= iNo; i++)&#xA;        factorial *= i;&#xA;        System.out.println ( i + &quot;! = &quot; + factorial(i));&#xA;&#xA;&#xA;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="3416341" LastEditorUserId="3416341" LastEditDate="2014-03-20T17:37:32.127" LastActivityDate="2014-03-20T17:37:32.127" Title="Having trouble with my java factorial assignment" Tags="&lt;java&gt;&lt;factorial&gt;" AnswerCount="4" CommentCount="8" />
  <row Id="22539548" PostTypeId="2" ParentId="22539430" CreationDate="2014-03-20T16:39:00.047" Score="-2" Body="&lt;pre&gt;&lt;code&gt;public static int factorial(int n)&#xA;{&#xA;  if(n == 1)&#xA;     return ?&#xA;  else&#xA;      return n* factorial(n - ?);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Maybe help you a little&lt;/p&gt;&#xA;" OwnerUserId="2166592" LastEditorUserId="2166592" LastEditDate="2014-03-20T16:49:00.913" LastActivityDate="2014-03-20T16:49:00.913" CommentCount="0" />
  <row Id="22560622" PostTypeId="1" CreationDate="2014-03-21T13:48:03.643" Score="0" ViewCount="84" Body="&lt;p&gt;I am a fresh student in computer science and currently we study Java recursion. Unfortunately, The academy only explains the following regarding this topic:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;What recursion means. &lt;/li&gt;&#xA;&lt;li&gt;There are 2 types of cases when using a recursive algorithm: base cases and recursive cases and their purpose.&lt;/li&gt;&#xA;&lt;li&gt;An exmaple of factorial and Fibonacci implementation using recursion. &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Now I got the following exercise:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Two integer numbers will be called &quot;strangers&quot; if their  greatest common divisor (aka GTC) is &lt;strong&gt;ONLY&lt;/strong&gt; 1&quot;. For example, the numbers 8 and 9 are &quot;strangers&quot; because their GTC is 1. However, 8 and 9 are not &quot;strangers&quot; because their GTC is 2. &lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Please implement a recursive method which receives an array of integers, and returns &quot;true&quot; if every pair numbers in this array are strangers, and &quot;false&quot; otherwise. &lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Method signature must be as follows:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public boolean checkGCD(int[] values)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;  &#xA;  &lt;p&gt;For example: &lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;{3, 5, 7, 11} -&gt; method will returns true.&lt;br&gt;&#xA;  {4, 7, 8, 9} -&gt; method will returns false because 4 and 8 are not strangers.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;For assistance, you can use the following method for finding GTC (Euclidean algorithm):&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private static int gcd(int n, int m){&#xA;    if (m==0) &#xA;    return n;&#xA;&#xA;    return gcd(m,n % m);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;  &#xA;  &lt;p&gt;In addition, the method checkGCD(int[] values) should be overloaded...&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Loops cannot be used!&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Good Luck ... :-)&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The above can be done very easily with a nested loop, but I must use recursion!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I understand that I need to use an overloaded method which gets &lt;code&gt;the array&lt;/code&gt;, &lt;code&gt;lo index&lt;/code&gt; and &lt;code&gt;hi index&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So this is what I came up in mind:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;@@@@@@&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Base case: if there is at least one pair of numbers in the array which are not strangers, method returns false (no need to continue the comparison...).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;@@@@@@&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Comparison will be done in the following way: lo index points to the 1st cell -&gt; hi index points to the 2nd cell -&gt; comparing -&gt; hi index is incremented by 1 until it reaches the last cell of the array.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then, lo index is incremented by 1, and then repeating the above. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;So bottom line, I should compare the first cell to all consecutive cells, compare the 2nd to all consecutive cells, the 3rd etc... &lt;/p&gt;&#xA;&#xA;&lt;p&gt;@@@@@@@@&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If all pairs of numbers are strangers, I need something else to stop recursion. Therefore, if all pairs are strangers, it means that lo index and hi index will eventually point to the last cell (cause both lo and hi index has incremented gradually, and they reach the last array cell after all comparisons turned out to be OK i.e strangers). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The following is the overloaded function:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;   private static boolean checkGCD(int[] values, int lo, int hi)&#xA;    {&#xA;&#xA;        if ( (gcd(values[lo], values[hi]) )!= 1 )&#xA;            return false;&#xA;&#xA;        else if (lo &amp;lt; values.length-1 &amp;amp;&amp;amp; hi &amp;lt; values.length-1)&#xA;                return checkGCD(values, lo, hi+1);&#xA;        else if (lo &amp;lt; values.length-2 &amp;amp;&amp;amp; hi == values.length-1)&#xA;                return checkGCD (values, lo+1, lo+2);&#xA;&#xA;        if (lo == values.length-1 &amp;amp;&amp;amp; hi == values.length-1)&#xA;            return true;&#xA;&#xA;         } -&amp;gt; Compiler says &quot;missing return statement&quot;**&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;The following is the method the exercise requires to have, and it basically just calls the overloaded method which does everything recursively.       &lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt; public static boolean checkGCD(int[] values)&#xA;  {&#xA;      return checkGCD(values, 0, 1);      &#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;When I try to compile, I get &quot;missing return statement&quot; which points to the close bracket in the overloaded function&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But I do use &quot;return&quot; in the overloaded function. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Please clarify how to fix. I am sure after compilation error, the above overloaded function &#xA;is still not OK.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Please assist. I am dealing with this exercise for hours&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thanks, &lt;/p&gt;&#xA;" OwnerUserId="3426550" LastEditorUserId="3426550" LastEditDate="2014-03-21T13:55:08.510" LastActivityDate="2014-03-22T11:08:03.933" Title="Java Recursion compilation error" Tags="&lt;java&gt;&lt;recursion&gt;" AnswerCount="5" CommentCount="6" FavoriteCount="0" />
  <row Id="22655123" PostTypeId="1" AcceptedAnswerId="22655193" CreationDate="2014-03-26T08:22:43.783" Score="0" ViewCount="21" Body="&lt;p&gt;I 'm trying to do a recurisve factorial function. My first try was:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public static int printFactorial(int n){&#xA;&#xA;        if(n&amp;lt;=1){&#xA;            System.out.println(n);&#xA;            return 1;&#xA;        }&#xA;        else{&#xA;            System.out.println(n);&#xA;            return printFactorial(n-1)*n;   &#xA;        }&#xA;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;And it worked fine but my printing is:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;3&#xA;2&#xA;1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;It's cool but how can I get an ascending printing like this:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1 &#xA;2&#xA;3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;I tried to do something like this:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public static int printFactorial(int n){&#xA;        int m=0;&#xA;        if(m==n){&#xA;            System.out.println(m);&#xA;            return m;&#xA;        }&#xA;        else{&#xA;            System.out.println(m);&#xA;            return printFactorial(m+1)*m;   &#xA;        }&#xA;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;But it didn't work. Why ?&lt;/p&gt;&#xA;" OwnerUserId="3208834" LastActivityDate="2014-03-26T08:26:59.797" Title="Recursive Factorial ascending printing in JAVA" Tags="&lt;recursion&gt;" AnswerCount="1" CommentCount="1" />
  <row Id="22655193" PostTypeId="2" ParentId="22655123" CreationDate="2014-03-26T08:26:59.797" Score="0" Body="&lt;p&gt;If you have an iterative version of the factorial function, this is easy to do:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public static void printFactorial(int n) {&#xA;&#xA;    int val = 1;&#xA;    for (int i = 1; i &amp;lt;= n; i++) {&#xA;        val *= i;&#xA;        System.out.println(val);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="838976" LastActivityDate="2014-03-26T08:26:59.797" CommentCount="0" />
  <row Id="22860709" PostTypeId="2" ParentId="891031" CreationDate="2014-04-04T10:50:08.857" Score="0" Body="&lt;p&gt;Factorial is highly increasing discrete function.So I think using BigInteger is better than using int.&#xA;I have implemented following code for calculation of factorial of non-negative integers.I have used recursion in place of using a loop. &lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public  BigInteger factorial(BigInteger x){     &#xA;    if(x.compareTo(new BigInteger(&quot;1&quot;))==0||x.compareTo(new BigInteger(&quot;0&quot;))==0)&#xA;        return new BigInteger(&quot;1&quot;);&#xA;    else return x.multiply(factorial(x.subtract(new BigInteger(&quot;1&quot;)))); &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Here the range of big integer is -2^Integer.MAX_VALUE (exclusive) to +2^Integer.MAX_VALUE,&#xA;where Integer.MAX_VALUE=2^31.&#xA;However the range of the factorial method given above can be extended up to twice by using unsigned BigInteger.&lt;/p&gt;&#xA;" OwnerUserId="2450410" LastActivityDate="2014-04-04T10:50:08.857" CommentCount="0" />
  <row Id="23249619" PostTypeId="1" CreationDate="2014-04-23T16:00:05.170" Score="0" ViewCount="47" Body="&lt;p&gt;I did a function to calculate the factorial of a number , but when i writes a decimal number or a character the &quot;mini-application&quot; does not work. How can i calculate the factorial of a decimal and launch a message error to the user when he writes a character .?&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt; private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {                                         &#xA;     // BOTON CALCULAR&#xA;&#xA;     String valortextfield = jTextField1.getText();&#xA;     int numero = Integer.parseInt(valortextfield);&#xA;     Metodos metod = new Metodos();&#xA;&#xA;     BigInteger resultado = metod.factorial(numero);&#xA;     String valorAmostrar= resultado.toString();&#xA;&#xA;     jTextArea1.setText(valorAmostrar);&#xA;&#xA;    }    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;the method :&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class Metodos {&#xA;&#xA;    public BigInteger factorial (int numero ){&#xA;    if ((numero &amp;lt; 0)||(numero &amp;gt;50)) {&#xA;&#xA;        return BigInteger.ZERO;&#xA;&#xA;&#xA;    } else if (numero==0){&#xA;&#xA;        return BigInteger.ONE;&#xA;&#xA;    } else {&#xA;        return BigInteger.valueOf(numero).multiply(factorial(numero-1));&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Any help will be appreciated..&lt;/p&gt;&#xA;" OwnerUserId="3325719" LastEditorUserId="3060123" LastEditDate="2014-04-23T16:03:56.497" LastActivityDate="2014-04-23T17:57:46.853" Title="Calculate factorial decimal in Java" Tags="&lt;java&gt;" AnswerCount="2" CommentCount="9" />
</posts>